apiVersion: v1
kind: Pod
metadata:
  name: cuda-ipc-concurrent-pod
  labels:
    app: cuda-ipc-concurrent-pod
spec:
  hostIPC: true
#   hostPID: true
  shareProcessNamespace: true
  nodeSelector:
    cloud.google.com/gke-accelerator: nvidia-tesla-a100

  # Both containers run concurrently (no initContainers)
  containers:

  # Producer container - runs continuously
  - name: producer
    image: nvidia/cuda:12.4.1-devel-ubuntu22.04
    command: ["/bin/bash", "-c"]
    args:
    - |
      cat > /tmp/producer.cu << 'EOF'
      #include <cuda_runtime.h>
      #include <stdio.h>
      #include <unistd.h>
      #include <stdlib.h>

      int main() {
          void* devPtr;
          cudaIpcMemHandle_t handle;

          printf("Producer: Initializing CUDA...\n");
          fflush(stdout);

          cudaError_t err = cudaSetDevice(0);
          if (err != cudaSuccess) {
              printf("ERROR setting CUDA device: %s\n", cudaGetErrorString(err));
              return 1;
          }

          printf("Producer: Allocating GPU memory...\n");
          fflush(stdout);
          err = cudaMalloc(&devPtr, 1024 * 1024); // 1MB
          if (err != cudaSuccess) {
              printf("ERROR allocating GPU memory: %s\n", cudaGetErrorString(err));
              return 1;
          }

          printf("Producer: Writing test data to GPU memory...\n");
          fflush(stdout);
          int* hostData = (int*)malloc(1024 * 1024);
          for (int i = 0; i < 256 * 1024; i++) {
              hostData[i] = i + 42; // Simple pattern: index + 42
          }
          err = cudaMemcpy(devPtr, hostData, 1024 * 1024, cudaMemcpyHostToDevice);
          if (err != cudaSuccess) {
              printf("ERROR copying data to GPU: %s\n", cudaGetErrorString(err));
              return 1;
          }

          printf("Producer: Creating IPC handle...\n");
          fflush(stdout);
          err = cudaIpcGetMemHandle(&handle, devPtr);
          if (err != cudaSuccess) {
              printf("ERROR creating IPC handle: %s\n", cudaGetErrorString(err));
              return 1;
          }

          printf("Producer: Writing handle to shared volume...\n");
          fflush(stdout);
          FILE* f = fopen("/shared/cuda_ipc_handle.dat", "wb");
          if (!f) {
              printf("ERROR: Could not open handle file for writing\n");
              return 1;
          }
          fwrite(&handle, sizeof(handle), 1, f);
          fclose(f);

          // Write ready signal for consumer
          f = fopen("/shared/producer_ready.flag", "w");
          if (f) {
              fprintf(f, "ready\n");
              fclose(f);
          }

          printf("Producer: Success! Memory contains values 42, 43, 44, 45, 46...\n");
          printf("Producer: Ready signal sent. Hanging infinitely to keep memory alive...\n");
          fflush(stdout);

          // Hang forever to keep the GPU memory allocated
          while (1) {
              sleep(3600);
          }

          return 0;
      }
      EOF

      echo "Producer: Compiling CUDA code..."
      nvcc /tmp/producer.cu -o /tmp/producer
      echo "Producer: Starting execution..."
      /tmp/producer
    resources:
      limits:
        nvidia.com/gpu: 1
    securityContext:
      privileged: true
      capabilities:
        add: ["IPC_LOCK"]
    volumeMounts:
    - name: shared-volume
      mountPath: /shared

  # Consumer container - waits for producer readiness
  - name: consumer
    image: nvidia/cuda:12.4.1-devel-ubuntu22.04
    command: ["/bin/bash", "-c"]
    args:
    - |
      echo "Consumer: Waiting for producer to be ready..."

      # Wait for producer ready signal (more reliable than just file existence)
      while [ ! -f /shared/producer_ready.flag ]; do
          echo "Consumer: Waiting for producer ready signal..."
          sleep 2
      done

      echo "Consumer: Producer is ready! Waiting 2 more seconds..."
      sleep 2

      # Verify handle file exists
      if [ ! -f /shared/cuda_ipc_handle.dat ]; then
          echo "ERROR: Handle file not found even after ready signal!"
          exit 1
      fi

      echo "Consumer: Handle file confirmed. Starting processing..."

      cat > /tmp/consumer.cu << 'EOF'
      #include <cuda_runtime.h>
      #include <stdio.h>
      #include <unistd.h>
      #include <stdlib.h>

      int main() {
          void* devPtr;
          cudaIpcMemHandle_t handle;

          printf("Consumer: Initializing CUDA...\n");
          fflush(stdout);

          cudaError_t err = cudaSetDevice(0);
          if (err != cudaSuccess) {
              printf("ERROR setting CUDA device: %s\n", cudaGetErrorString(err));
              return 1;
          }

          printf("Consumer: Reading IPC handle from shared volume...\n");
          fflush(stdout);
          FILE* f = fopen("/shared/cuda_ipc_handle.dat", "rb");
          if (!f) {
              printf("ERROR: Handle file not found\n");
              return 1;
          }
          fread(&handle, sizeof(handle), 1, f);
          fclose(f);

          printf("Consumer: Opening IPC memory handle...\n");
          fflush(stdout);
          err = cudaIpcOpenMemHandle(&devPtr, handle, cudaIpcMemLazyEnablePeerAccess);
          if (err != cudaSuccess) {
              printf("ERROR opening IPC handle: %s\n", cudaGetErrorString(err));
              return 1;
          }

          printf("Consumer: Successfully opened shared GPU memory!\n");
          fflush(stdout);

          // Read the data
          int* hostData = (int*)malloc(1024 * sizeof(int));
          err = cudaMemcpy(hostData, devPtr, 1024 * sizeof(int), cudaMemcpyDeviceToHost);
          if (err != cudaSuccess) {
              printf("ERROR reading GPU memory: %s\n", cudaGetErrorString(err));
              return 1;
          }

          printf("Consumer: First 10 values from shared memory: ");
          for (int i = 0; i < 10; i++) {
              printf("%d ", hostData[i]);
          }
          printf("\n");
          fflush(stdout);

          // Verify expected pattern (index + 42)
          bool correct = true;
          for (int i = 0; i < 1024; i++) {
              if (hostData[i] != i + 42) {
                  correct = false;
                  break;
              }
          }

          if (correct) {
              printf("Consumer: ✓ Data verification PASSED!\n");
          } else {
              printf("Consumer: ✗ Data verification FAILED!\n");
          }

          printf("Consumer: Success! Hanging infinitely...\n");
          fflush(stdout);

          // Hang forever
          while (1) {
              sleep(3600);
          }

          return 0;
      }
      EOF

      echo "Consumer: Compiling CUDA code..."
      nvcc /tmp/consumer.cu -o /tmp/consumer
      echo "Consumer: Starting execution..."
      /tmp/consumer
    resources:
      limits:
        nvidia.com/gpu: 1
    securityContext:
      privileged: true
      capabilities:
        add: ["IPC_LOCK"]
    volumeMounts:
    - name: shared-volume
      mountPath: /shared

  volumes:
  - name: shared-volume
    emptyDir: {}

  restartPolicy: Never